{"version":3,"sources":["../src/errors.ts","../src/operators/defaultOperators.ts","../src/operators/index.ts","../src/mapRuleToSQL.ts","../src/buildFilter.ts","../src/createCaslDrizzleAdapter.ts"],"names":["and"],"mappings":"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","file":"index.js","sourcesContent":["export class UnknownColumnError extends Error {\n    constructor(columnName: string) {\n        super(`Unknown column: ${columnName}`);\n        this.name = \"UnknownColumnError\";\n    }\n}\n\nexport class UnsupportedOperatorError extends Error {\n    constructor(operator: string) {\n        super(`Unsupported operator: ${operator}`);\n        this.name = \"UnsupportedOperatorError\";\n    }\n}\n","import { eq, inArray, type AnyColumn } from \"drizzle-orm\";\nimport type { OperatorFn } from \"../types\";\n\nexport const $eq: OperatorFn = (column: AnyColumn, value: unknown) => {\n    return eq(column, value);\n};\n\nexport const $in: OperatorFn = (column: AnyColumn, value: unknown) => {\n    if (!Array.isArray(value)) {\n        throw new Error(\"$in operator expects an array value\");\n    }\n    return inArray(column, value);\n};\n","import type { OperatorMap } from \"../types\";\nimport { $eq, $in } from \"./defaultOperators\";\n\nexport const defaultOperators: OperatorMap = {\n    $eq,\n    $in,\n};\n","import { SQL, and, PgTable, getTableColumns } from \"drizzle-orm\";\nimport { OperatorMap } from \"./types\";\nimport { UnknownColumnError, UnsupportedOperatorError } from \"./errors\";\n\nexport function mapRuleToSQL(opts: {\n    rule: Record<string, any>;\n    table: PgTable;\n    operators: OperatorMap;\n}): SQL | null {\n    const { rule, table, operators } = opts;\n    const conditions: SQL[] = [];\n    const validColumns = getTableColumns(table);\n\n    // Iterate fields, not rules\n    // Rule shape: { field: value } or { field: { $op: value } }\n    for (const [field, value] of Object.entries(rule)) {\n        // Unknown column check\n        // Note: drizzle's getTableColumns returns a map where keys are property names in the table object\n        // Assuming field names in CASL rule match property names in Drizzle table definition\n        const column = validColumns[field];\n        if (!column) {\n            throw new UnknownColumnError(field);\n        }\n\n        // Check value shape\n        if (\n            value !== null &&\n            typeof value === \"object\" &&\n            !Array.isArray(value) &&\n            Object.keys(value).some((k) => k.startsWith(\"$\"))\n        ) {\n            // It's an operator object e.g. { $in: [...] }\n            for (const [op, opValue] of Object.entries(value)) {\n                if (!op.startsWith(\"$\")) {\n                    // Mixed operator and direct value is not valid in standard CASL v1 flat structure usually\n                    // But we only care about operators here.\n                    // \"Field-level rules\" are disallowed by spec, but { field: { nested: val } } is usually relation.\n                    // Spec says \"Unknown operators\" -> throw.\n                    // If key doesn't start with $, it might be treated as a nested field which is unsupported.\n                    // However, spec says \"Flat conditions\", \"Nested $and, $or -> throw\".\n                    // If we encounter a key that is not an operator in this position, it's ambiguous.\n                    // Given \"Fail closed\", let's treat any object key under a field that we are processing as an operator.\n                    // If it's not in the map, throw.\n                    throw new UnsupportedOperatorError(op);\n                }\n\n                const operatorFn = operators[op];\n                if (!operatorFn) {\n                    throw new UnsupportedOperatorError(op);\n                }\n                conditions.push(operatorFn(column, opValue));\n            }\n        } else {\n            // Direct equality: { field: value }\n            const eqOp = operators[\"$eq\"];\n            // $eq is always present as per spec, but good to be safe/consistent\n            if (!eqOp) {\n                // Should technically not happen if defaults are used but strictness check\n                throw new UnsupportedOperatorError(\"$eq\");\n            }\n            conditions.push(eqOp(column, value));\n        }\n    }\n\n    if (conditions.length === 0) {\n        return null;\n    }\n\n    // Multiple fields -> and(...)\n    return and(...conditions) || null;\n}\n","import { SQL, and, or, sql, not } from \"drizzle-orm\";\nimport { PgTable } from \"drizzle-orm/pg-core\";\nimport type { AccessRule, OperatorMap } from \"./types\";\nimport { mapRuleToSQL } from \"./mapRuleToSQL\";\n\nexport function buildFilter(\n    rules: AccessRule[],\n    table: PgTable,\n    operators: OperatorMap\n): SQL | null {\n    const canRules = rules.filter((r) => !r.inverted && r.conditions);\n    const cannotRules = rules.filter((r) => r.inverted && r.conditions);\n\n    const allowFilters = canRules\n        .map((r) => mapRuleToSQL({ rule: r.conditions!, table, operators }))\n        .filter((f): f is SQL => !!f);\n\n    const denyFilters = cannotRules\n        .map((r) => mapRuleToSQL({ rule: r.conditions!, table, operators }))\n        .filter((f): f is SQL => !!f);\n\n    if (allowFilters.length === 0 && denyFilters.length === 0) {\n        return null;\n    }\n\n    if (allowFilters.length === 0) {\n        return sql`false`;\n    }\n\n    const allow = or(...allowFilters)!;\n\n    if (denyFilters.length === 0) {\n        return allow || null; // 'allow' could be undefined if array was empty but we handled that check above? \n        // Wait, allowFilters.length > 0 means or(...) returns SOMETHING. \n        // drizzle's 'or' with 1 arg returns that arg. \n        // 'or' with >1 args returns SQL.\n        // 'or' with 0 args is undefined? But we checked length === 0.\n        // So 'allow' is SQL.\n    }\n\n    const deny = not(or(...denyFilters));\n\n    return and(allow, deny) || null;\n}\n","import { PgTable } from \"drizzle-orm/pg-core\";\nimport { SQL } from \"drizzle-orm\";\nimport type { AccessRule, CaslDrizzleAdapter, OperatorMap } from \"./types\";\nimport { defaultOperators } from \"./operators\";\nimport { buildFilter } from \"./buildFilter\";\nimport type { Ability, AbilityTuple, MongoQuery, SubjectType } from \"@casl/ability\";\n\nexport function createCaslDrizzleAdapter(opts: {\n    table: PgTable;\n    operators?: OperatorMap;\n}): CaslDrizzleAdapter {\n    const { table, operators: customOperators } = opts;\n\n    // Custom operators EXTEND defaults, they do NOT replace them.\n    const operators: OperatorMap = {\n        ...defaultOperators,\n        ...customOperators,\n    };\n\n    return {\n        filterFromRules(rules: AccessRule[]): SQL | null {\n            return buildFilter(rules, table, operators);\n        },\n\n        filterFromAbility(\n            ability: Ability<AbilityTuple, MongoQuery>,\n            action: string,\n            subject: SubjectType\n        ): SQL | null {\n            const rules = ability.rulesFor(action, subject);\n            // AccessRule loosely matches CASL Rule, but we cast to satisfy strict TS\n            // and explicitly handle the undefined fields potential mismatch if strict null checks are on.\n            return buildFilter(rules as unknown as AccessRule[], table, operators);\n        },\n    };\n}\n"]}